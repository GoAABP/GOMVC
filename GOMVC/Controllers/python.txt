{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "f880b8be",
   "metadata": {},
   "source": [
    "# Generación de base de operaciones diaria Cobranza."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "db132529",
   "metadata": {},
   "source": [
    "## Importamos las librerias"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "6bae4a6a",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Importando las librerias a utilizar\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import datetime\n",
    "import calendar\n",
    "import os"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d31eb1c8",
   "metadata": {},
   "source": [
    "## Definimos todas las funciones que utlizaremos a lo largo del proceso."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "3f3c92ec",
   "metadata": {},
   "outputs": [],
   "source": [
    "#definimos una funcion para agregar la columna condicional del bkt inicial\n",
    "def determinar_bktinicial(Estatus, DiasAtraso):\n",
    "    if DiasAtraso <= 0 and Estatus == 'Activo':\n",
    "        return \"0\"\n",
    "    else:\n",
    "        if DiasAtraso <31 and Estatus =='Activo':\n",
    "            return \"1 a 30\"\n",
    "        else:\n",
    "            if DiasAtraso <61 and Estatus =='Activo':\n",
    "                return \"31 a 60\"\n",
    "            else:\n",
    "                if DiasAtraso <91 and Estatus =='Activo':\n",
    "                    return \"61 a 90\"\n",
    "                else:\n",
    "                    if DiasAtraso <121 and Estatus =='Activo':\n",
    "                        return \"91 a 120\"\n",
    "                    else:\n",
    "                        if DiasAtraso <151 and Estatus =='Activo':\n",
    "                            return \"121 a 150\"\n",
    "                        else:\n",
    "                            if DiasAtraso <181 and Estatus =='Activo':\n",
    "                                return \"151 a 180\"\n",
    "                            else:\n",
    "                                if DiasAtraso >=181 and Estatus =='Activo':\n",
    "                                        return \"181 +\"\n",
    "                                else: \n",
    "                                    return Estatus"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "a717de6f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# definimos una función para agregar la columna condicional del bkt inicial\n",
    "def determinar_bktinicial(Estatus, DiasAtraso, TipoFinanciamiento):\n",
    "    if TipoFinanciamiento in ['NOM', 'NCCAR', 'REFI', 'REST', 'NOM FACT']:\n",
    "        # Aquí realiza el cálculo para estos tipos de financiamiento\n",
    "        if DiasAtraso <= 0 and Estatus == 'Activo':\n",
    "            return \"0\"\n",
    "        else:\n",
    "            if DiasAtraso < 31 and Estatus == 'Activo':\n",
    "                return \"1 a 30\"\n",
    "            else:\n",
    "                if DiasAtraso < 61 and Estatus == 'Activo':\n",
    "                    return \"31 a 60\"\n",
    "                else:\n",
    "                    if DiasAtraso < 91 and Estatus == 'Activo':\n",
    "                        return \"61 a 90\"\n",
    "                    else:\n",
    "                        if DiasAtraso < 121 and Estatus == 'Activo':\n",
    "                            return \"91 a 120\"\n",
    "                        else:\n",
    "                            if DiasAtraso < 151 and Estatus == 'Activo':\n",
    "                                return \"121 a 150\"\n",
    "                            else:\n",
    "                                if DiasAtraso < 181 and Estatus == 'Activo':\n",
    "                                    return \"151 a 180\"\n",
    "                                else:\n",
    "                                    if DiasAtraso < 271 and Estatus == 'Activo':\n",
    "                                        return \"181 a 270\"\n",
    "                                    else:\n",
    "                                        if DiasAtraso >= 271 and Estatus == 'Activo':\n",
    "                                            return \"271 +\"\n",
    "                                        else:\n",
    "                                            return Estatus\n",
    "    else:\n",
    "        # Si el tipo de financiamiento no está en la lista, realiza el cálculo predeterminado\n",
    "        if DiasAtraso <= 0 and Estatus == 'Activo':\n",
    "            return \"0\"\n",
    "        else:\n",
    "            if DiasAtraso < 31 and Estatus == 'Activo':\n",
    "                return \"1 a 30\"\n",
    "            else:\n",
    "                if DiasAtraso < 61 and Estatus == 'Activo':\n",
    "                    return \"31 a 60\"\n",
    "                else:\n",
    "                    if DiasAtraso < 91 and Estatus == 'Activo':\n",
    "                        return \"61 a 90\"\n",
    "                    else:\n",
    "                        if DiasAtraso < 121 and Estatus == 'Activo':\n",
    "                            return \"91 a 120\"\n",
    "                        else:\n",
    "                            if DiasAtraso < 151 and Estatus == 'Activo':\n",
    "                                return \"121 a 150\"\n",
    "                            else:\n",
    "                                if DiasAtraso < 181 and Estatus == 'Activo':\n",
    "                                    return \"151 a 180\"\n",
    "                                else:\n",
    "                                    if DiasAtraso >= 181 and Estatus == 'Activo':\n",
    "                                        return \"181 +\"\n",
    "                                    else:\n",
    "                                        return Estatus\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "694d9174",
   "metadata": {},
   "outputs": [],
   "source": [
    "import datetime\n",
    "\n",
    "def determinar_MesQuebranto(Estatus, DiasAtraso, UN_Financiamiento):\n",
    "    if Estatus == 'Activo':\n",
    "        fecha_actual = datetime.datetime.now()\n",
    "\n",
    "        # Lógica para determinar el límite de días según el tipo de financiamiento\n",
    "        if UN_Financiamiento == 'DxD':\n",
    "            dias_limite = 181\n",
    "        elif UN_Financiamiento == 'DxN':\n",
    "            dias_limite = 271\n",
    "        elif UN_Financiamiento == 'DxS':\n",
    "            dias_limite = 271\n",
    "        else:\n",
    "            return 0  # Devolver 0 si el financiamiento no es \"electrónico\" ni \"nómina\"\n",
    "\n",
    "        # Verificar si DiasAtraso es menor o igual al límite de días\n",
    "        if DiasAtraso <= dias_limite:\n",
    "            # Calcular la fecha objetivo\n",
    "            fecha_objetivo = fecha_actual + datetime.timedelta(days=(dias_limite - DiasAtraso))\n",
    "            return fecha_objetivo\n",
    "        else:\n",
    "            return fecha_actual  # Devolver fecha_actual si DiasAtraso es mayor al límite de días\n",
    "    else:\n",
    "        return 0  # Devolver 0 si Estatus no es 'Activo'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "4f0175cc",
   "metadata": {},
   "outputs": [],
   "source": [
    "def calcular_propenso_a_castigo(row):\n",
    "    if row['UN_Financiamiento'] == 'DxD':\n",
    "        dias_limite = 181\n",
    "    elif row['UN_Financiamiento'] == 'DxN':\n",
    "        dias_limite = 271\n",
    "    elif row['UN_Financiamiento'] == 'DxS':\n",
    "        dias_limite = 271\n",
    "    else:\n",
    "        return False  # Si el financiamiento no es \"electrónico\" ni \"nómina\", no se cumple la condición\n",
    "\n",
    "    if row['Estatus'] == 'Activo' and (row['DiasAtraso Inicial'] + row['Dias para terminar el mes']) >= dias_limite:\n",
    "        return 'Propenso a Castigo'\n",
    "    else:\n",
    "        return False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "956e51b4",
   "metadata": {},
   "outputs": [],
   "source": [
    "#definimos una funcion para agregar la columna condicional Cantidad de Cuotas pagadas\n",
    "def determinar_CuotasPagadas(Estatus, AmortPagadas):\n",
    "    if AmortPagadas <= 0 and (Estatus == 'Activo' or Estatus == 'Cerrado'):\n",
    "        return \"0\"\n",
    "    else:\n",
    "        if AmortPagadas <=2 and (Estatus == 'Activo' or Estatus == 'Cerrado'):\n",
    "            return \"1 a 2\"\n",
    "        else:\n",
    "            if AmortPagadas <=5 and (Estatus == 'Activo' or Estatus == 'Cerrado'):\n",
    "                return \"3 a 5\"\n",
    "            else:\n",
    "                if AmortPagadas <=10 and (Estatus == 'Activo' or Estatus == 'Cerrado'):\n",
    "                    return \"6 a 10\"\n",
    "                else:\n",
    "                    if AmortPagadas >=11 and (Estatus == 'Activo' or Estatus == 'Cerrado'):\n",
    "                        return \"11 o más\"\n",
    "                    else:\n",
    "                        return Estatus"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "118fe91d",
   "metadata": {},
   "outputs": [],
   "source": [
    "#definimos una funcion para agregar la columna condicional Del Score de Prioridad segun las caracteristicas del crédito\n",
    "def dias_restantes_mes():\n",
    "    now = datetime.datetime.now()\n",
    "    _, last_day = calendar.monthrange(now.year, now.month)\n",
    "    return last_day - now.day\n",
    "\n",
    "def determinar_Score(CuotasPagRango, Bandera, DiasAtraso):\n",
    "    dias_restantes = dias_restantes_mes()\n",
    "\n",
    "    if DiasAtraso + dias_restantes >= 181:\n",
    "        return 1\n",
    "    elif Bandera == 'FPD' or Bandera == 'Anulación' or ((Bandera == 'Sin Pago' or Bandera == '<50%' or Bandera == '51%-99%') and (CuotasPagRango == '0' or CuotasPagRango =='1 a 2')):\n",
    "        return 1\n",
    "    elif (Bandera == 'Sin Pago' or Bandera == '<50%' or Bandera == '51%-99%') and (CuotasPagRango == '3 a 5' or CuotasPagRango =='6 a 10'):\n",
    "        return 2\n",
    "    elif (Bandera == 'Sin Pago' or Bandera == '<50%' or Bandera == '51%-99%') and CuotasPagRango =='11 o más':\n",
    "        return 3\n",
    "    else:\n",
    "        return 4\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "69e42380",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "def EtiquetaLegal(Estatus,vCollectStatus,UN_Financiamiento,Abreviatura,EstatusDef,SaldoQ_Contable,UN_Dependencia,DiasAtraso,SaldoContable,MontoUltimoPago,AmortPagadas):\n",
    "    if Estatus == 'Castigado':\n",
    "        if vCollectStatus == 'QUEBRANTO PAGADO':\n",
    "            if UN_Financiamiento == 'DxN':\n",
    "                if Abreviatura == 'Saldado' or Abreviatura == 'Liquidación':\n",
    "                    return 'Asignación Quebranto NOM Pagado'\n",
    "                else:\n",
    "                    return 'No aplica Etiqueta Legal / Motivo'\n",
    "            elif UN_Financiamiento == 'DxD':\n",
    "                return 'Asignación Quebranto DOM Pagado'\n",
    "            else:\n",
    "                return 'No aplica Etiqueta Legal / Financiamiento' \n",
    "        else:\n",
    "            if EstatusDef == 1:\n",
    "                if UN_Financiamiento == 'DxN':\n",
    "                    return 'Asignación Quebranto NOM Defunción'\n",
    "                elif UN_Financiamiento == 'DxD':\n",
    "                    return 'Asignación Quebranto DOM Defunción'\n",
    "                else:\n",
    "                    return 'No aplica Etiqueta Legal / Financiamiento'\n",
    "            else:\n",
    "                if UN_Financiamiento == 'DxN':\n",
    "                    if Abreviatura == 'Saldado' or Abreviatura == 'Liquidación' or Abreviatura == 'Pagando' or Abreviatura == 'Defunción':\n",
    "                        return 'No aplica Etiqueta Legal / Motivo'\n",
    "                    else:\n",
    "                        if UN_Dependencia == 'Snte 38' or UN_Dependencia == 'Snte 21' or UN_Dependencia == 'Snte 35':\n",
    "                            return 'No aplica Etiqueta Legal / Dependencia'\n",
    "                        else:\n",
    "                            if SaldoQ_Contable <= 5000:\n",
    "                                return 'Asignación Quebranto NOM Saldos Menores'\n",
    "                            else:\n",
    "                                return 'Asignación Quebranto NOM'\n",
    "                elif UN_Financiamiento == 'DxD':\n",
    "                    if SaldoQ_Contable <= 5000:\n",
    "                        return 'Asignación Quebranto DOM Saldos Menores'\n",
    "                    else:\n",
    "                        return 'Asignación Quebranto DOM'\n",
    "                else:\n",
    "                    return 'No aplica Etiqueta Legal / Financiamiento' \n",
    "    elif Estatus == 'Activo':\n",
    "        if UN_Financiamiento == 'DxN':\n",
    "            if DiasAtraso >=1 :\n",
    "                if DiasAtraso >=120 :\n",
    "                    if Abreviatura == 'Cobranza Directa' or Abreviatura == 'Entrega Sin Documentos' or Abreviatura == 'Sobregiro' or Abreviatura == 'Sin Respuesta' or Abreviatura == 'Embargo Nómina' or Abreviatura == 'Convenio Judicial' or Abreviatura == 'C. x Amparo' or Abreviatura == 'PSGS' or Abreviatura == 'No Instalado' or Abreviatura == 'Incapacidad Medica' or Abreviatura == 'Pensionado' or Abreviatura == 'Sin Plaza' or Abreviatura == 'Pensionado' or Abreviatura == 'Pensionado':\n",
    "                        if UN_Dependencia == 'Snte 38' or UN_Dependencia == 'Snte 21' or UN_Dependencia == 'Snte 35':\n",
    "                            return 'No aplica Etiqueta Legal / Dependencia'\n",
    "                        else:\n",
    "                            if SaldoContable <=5000:\n",
    "                                return 'Asignación por Mora 120+ NOM Saldos Menores'\n",
    "                            else:\n",
    "                                return 'Asignación por Mora 120+ NOM'\n",
    "                    else:\n",
    "                        return 'No aplica Etiqueta Legal / Motivo'\n",
    "                else:\n",
    "                    if Abreviatura == 'Cobranza Directa' or Abreviatura == 'Baja Despido' or Abreviatura == 'Sin Respuesta' or Abreviatura == 'Embargo Nómina' or Abreviatura == 'Baja x Jubilación' or Abreviatura == 'Convenio Judicial' or Abreviatura == 'Baja Renuncia' or Abreviatura == 'Sin Plaza' or Abreviatura == 'Sin Listas' or Abreviatura == 'Convenio Extrajudicial':\n",
    "                        if SaldoContable <=5000:\n",
    "                            return 'Asignación Natural NOM Saldos Menores'\n",
    "                        else:\n",
    "                            return 'Asignación Natural NOM'\n",
    "                    else:\n",
    "                        return 'No aplica Etiqueta Legal / Motivo'\n",
    "            else:\n",
    "                return 'No aplica Etiqueta Legal / Dias Atraso'\n",
    "        elif UN_Financiamiento == 'DxD':\n",
    "            if DiasAtraso >=1 :\n",
    "                if DiasAtraso >= 60:\n",
    "                    if AmortPagadas == 0:\n",
    "                        if SaldoContable <=5000:\n",
    "                            return 'Asignación FPD DOM Saldos Menores'\n",
    "                        else:\n",
    "                            return 'Asignación FPD DOM'\n",
    "                    else:\n",
    "                        if SaldoContable <=5000:\n",
    "                            return 'Asignación Natural DOM Saldos Menores'\n",
    "                        else:\n",
    "                            return 'Asignación Natural DOM'\n",
    "                else:\n",
    "                    if MontoUltimoPago <0:\n",
    "                        if SaldoContable <=5000:\n",
    "                            return 'Asignación Reverso DOM Saldos Menores'\n",
    "                        else:\n",
    "                            return 'Asignación Reverso DOM'\n",
    "                    else:\n",
    "                        return 'No aplica Etiqueta Legal / Monto Ultimo Pago'\n",
    "            else:\n",
    "                return 'No aplica Etiqueta Legal / Dias Atraso'\n",
    "        else:\n",
    "            return 'No aplica Etiqueta Legal / Financiamiento' \n",
    "    else:\n",
    "        return 'No aplica Etiqueta Legal / Estatus'"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c4d644af",
   "metadata": {},
   "source": [
    "## Definimos la fecha de trabajo del proceso"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "4f45d025",
   "metadata": {},
   "outputs": [],
   "source": [
    "fecha_actual = datetime.datetime.now()\n",
    "#fecha_actual = datetime.datetime(2024,10,31)\n",
    "dtype_dict = {'Clave': str}\n",
    "\n",
    "hoy = fecha_actual.date()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2e2375ab",
   "metadata": {},
   "source": [
    "## Leemos todos los archivos que utilizaremos como df,diccionarios, listas, etc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "aeaf8bae",
   "metadata": {},
   "outputs": [],
   "source": [
    "df_UdDependencia = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/Ud_Dependencia.xlsx\")\n",
    "df_Financiamiento = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/TipoFinanciamiento.xlsx\")\n",
    "df_Plazas = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/CatalogoPlazas.xlsx\", sheet_name='Act 11 Noviembre 2024')\n",
    "df_Contable = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/SaldosContableDiario.xlsx\")\n",
    "df_Bancos = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/CatalogoBancos.xlsx\",dtype=dtype_dict)\n",
    "df_Cartera = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/SaldosCarteraDiario.xlsx\",engine='openpyxl')\n",
    "df_Otorgamientos = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/Otorgamientos/Acumulado de Otorgamientos.xlsx\")\n",
    "df_Demograficos = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/Demograficos.xlsx\",engine='openpyxl')\n",
    "df_legal = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/BaseLegal.xlsx\",engine='openpyxl')\n",
    "df_Quebrantos = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/BD_QuebrantosSinEstrategia.xlsx\",engine='openpyxl')\n",
    "df_CarteraAlmacenada = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/SaldosCarteraIniciales.xlsx\")\n",
    "df_EstatusDomi = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoAsignacion/BD_EstatusDomi.xlsx\",sheet_name='Domi')\n",
    "dfEstrategias = pd.read_excel('C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/PagosEstrategiasAcumulado.xlsx')\n",
    "df_ResultadoAvance = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/CatalogoResultadoAvance.xlsx\")\n",
    "df_AreaGestor = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/CatalogoGestoresArea.xlsx\")\n",
    "df_InfoQuebrantos = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/InformacionQuebrantos.xlsx\")\n",
    "df_CatalogoMotivos = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/CatalogoMotivo.xlsx\")\n",
    "df_legalMC = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/BaseLegalMC.xlsx\",engine='openpyxl')\n",
    "\n",
    "df_EstatusDef = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/BD_OficialAcumuladoDefunciones.xlsx\",sheet_name='ACUMULADO',header=0)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "cd133449",
   "metadata": {},
   "outputs": [],
   "source": [
    "# set directory where the files are stored\n",
    "directory = \"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/Pagos\"\n",
    "\n",
    "# create an empty list to store all the dataframes\n",
    "df_list = []\n",
    "\n",
    "# loop through all the files in the directory\n",
    "for filename in os.listdir(directory):\n",
    "    if filename.endswith(\".csv\"):\n",
    "        # read the file into a dataframe\n",
    "        df = pd.read_csv(os.path.join(directory, filename),encoding='latin1',low_memory=False)\n",
    "        \n",
    "        # add a column to the dataframe with the filename\n",
    "        df['File Name'] = filename\n",
    "        \n",
    "        # append the dataframe to the list\n",
    "        df_list.append(df)\n",
    "    \n",
    "# concatenate all the dataframes into a single dataframe\n",
    "dfHistoricoPagos = pd.concat(df_list, ignore_index=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "dd1f1ed3",
   "metadata": {},
   "outputs": [],
   "source": [
    "# set directory where the files are stored\n",
    "directory = \"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/Gestiones\"\n",
    "\n",
    "# create an empty list to store all the dataframes\n",
    "df_list = []\n",
    "\n",
    "# loop through all the files in the directory\n",
    "for filename in os.listdir(directory):\n",
    "    if filename.endswith(\".xlsx\"):\n",
    "        # read the file into a dataframe\n",
    "        df = pd.read_excel(os.path.join(directory, filename))\n",
    "        \n",
    "        # add a column to the dataframe with the filename\n",
    "        df['File Name'] = filename\n",
    "        \n",
    "        # append the dataframe to the list\n",
    "        df_list.append(df)\n",
    "    \n",
    "# concatenate all the dataframes into a single dataframe\n",
    "appended_df = pd.concat(df_list, ignore_index=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "01b9bf56",
   "metadata": {},
   "source": [
    "## Continuamos con cada uno de los procesos de cada archivo."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "efe144de",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Realizamos los diccionarios con los df que trabajaremos.\n",
    "dic_udDependencia = df_UdDependencia.set_index('Dependencia')['Abrev.'].to_dict()\n",
    "dic_Financiamiento = df_Financiamiento.set_index('Tipo de Credito')['Producto'].to_dict()\n",
    "dic_Plazas = df_Plazas.set_index('Id Credito')['Plaza'].to_dict()\n",
    "dic_Contable = df_Contable.set_index('Id Credito')['Saldo Contable'].to_dict()\n",
    "dic_Cartera = df_Cartera.set_index('Id Credito')['IdPersona'].to_dict()\n",
    "dic_EtapaLegal = df_legal.set_index('Id_Credito')['EtapaActual'].to_dict()\n",
    "dic_EstatusDomi = df_EstatusDomi.set_index('ID CREDITO')['RECHAZO'].to_dict()\n",
    "dic_ResultadoAvance = df_ResultadoAvance.set_index('CLAVE')['Resultado'].to_dict()\n",
    "dic_AreaGestor = df_AreaGestor.set_index('Usuario MC')['Área'].to_dict()\n",
    "\n",
    "dic_EstatusDef = df_EstatusDef.drop_duplicates('IdPersona').set_index('IdPersona')[['ESTATUS DEFUNCION']].assign(Valor=1).to_dict()['Valor']\n",
    "\n",
    "# Especifica el tipo de dato de la columna que contiene el valor \"001\" como una cadena de caracteres (str)\n",
    "dic_Bancos = df_Bancos.set_index('Clave')['Nombre corto'].to_dict()\n",
    "\n",
    "# seleccionar la columna que te interesa\n",
    "IdPago = dfEstrategias['Id Pago']\n",
    "# convertir la columna en una lista\n",
    "lista = IdPago.tolist()\n",
    "\n",
    "# seleccionar la columna que te interesa\n",
    "IdCreditoQuebranto = df_InfoQuebrantos['Operacion']\n",
    "# convertir la columna en una lista\n",
    "listaQuebrantosR1 = IdCreditoQuebranto.tolist()\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "c913d261",
   "metadata": {},
   "outputs": [],
   "source": [
    "df_InfoQuebrantos['Q Contable'] = df_InfoQuebrantos['K-Vigente'] + df_InfoQuebrantos['K-Vencido'] + df_InfoQuebrantos['IntVencido']+ df_InfoQuebrantos['IVAIntVencido']\n",
    "df_InfoQuebrantos['Q Capital'] = df_InfoQuebrantos['K-Vigente'] + df_InfoQuebrantos['K-Vencido']\n",
    "\n",
    "df_InfoQuebrantos = df_InfoQuebrantos.loc[:, ['Operacion','Q Contable','Q Capital','FechaQuebranto']]\n",
    "dic_fechaQuebranto = df_InfoQuebrantos.set_index('Operacion')['FechaQuebranto'].to_dict()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "2d904d40",
   "metadata": {},
   "outputs": [],
   "source": [
    "df_legalMC = df_legalMC.sort_values(by='Fecha De Presentacion', ascending=False)\n",
    "df_legalMC = df_legalMC.drop_duplicates(subset=['Crédito'])\n",
    "df_legalMC['Crédito'] = df_legalMC['Crédito'].astype(int)\n",
    "#dic_EtapaLegalMC = df_legalMC.set_index('Crédito')['Etapa Procesal'].to_dict()\n",
    "dic_EtapaLegalMC = df_legalMC.set_index('Crédito')[['Etapa Procesal', 'Bandera PP Juicio']].apply(tuple, axis=1).to_dict()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "992130ff",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Proceso de la base de Otorgamientos. Cálculo del capital Total Liberado, el cual es el monto el cual el cliente obtiene.\n",
    "df_Otorgamientos['Persona'] = df_Otorgamientos['Id Credito'].map(dic_Cartera)\n",
    "\n",
    "# Creas una nueva columna que sea la concatenación de 'Id Credito', 'Persona' y 'Capital'\n",
    "df_Otorgamientos['Concatenacion'] = df_Otorgamientos['Id Credito'].astype(str) + df_Otorgamientos['Persona'].astype(str) + df_Otorgamientos['Capital'].astype(str)\n",
    "\n",
    "# Eliminas las filas duplicadas basadas en la columna 'Concatenacion'\n",
    "df_Otorgamientos = df_Otorgamientos.drop_duplicates(subset='Concatenacion', keep='first')\n",
    "\n",
    "# Eliminas la columna 'Concatenacion' si ya no la necesitas\n",
    "df_Otorgamientos = df_Otorgamientos.drop(columns=['Concatenacion'])\n",
    "\n",
    "df_Otorgamientos['Capital Total Dispersado']= df_Otorgamientos['Comision']+df_Otorgamientos['IVA']+df_Otorgamientos['Cobertura']+df_Otorgamientos['IVA Cobertura']+df_Otorgamientos['Disposicion']+df_Otorgamientos['Pago de Deuda']+df_Otorgamientos['Comisión Financiada']+df_Otorgamientos['IVA Comisión Financ.']\n",
    "df_Otorgamientos = df_Otorgamientos.loc[:, ['Id Credito','Persona','Nombre Vendedor','vSupName','Producto','Capital Total Dispersado']]\n",
    "\n",
    "#Suma_dinero es un data en el cual se agrupa por persona el monto total dispersado al cliente sin importar el financiamiento.\n",
    "suma_dinero = df_Otorgamientos.groupby('Persona')['Capital Total Dispersado'].sum()\n",
    "\n",
    "#df_Otorgamientos es un data el cual guarda una relacion Id Credito con su Vendedor y Supervisor\n",
    "df_Otorgamientos = df_Otorgamientos.loc[:, ['Id Credito', 'Nombre Vendedor', 'vSupName','Producto','Capital Total Dispersado']].rename(columns={'vSupName': 'Nombre Supervisor','Capital Total Dispersado': 'Capital Total Dispersado Crédito'})\n",
    "\n",
    "#Suma_dinero es un data en el cual se agrupa por persona el monto total dispersado al cliente sin importar el financiamiento.\n",
    "suma_dineroCredito = df_Otorgamientos.groupby('Id Credito')['Capital Total Dispersado Crédito'].sum()\n",
    "\n",
    "#df_Otorgamientos es un data el cual guarda una relacion Id Credito con su Vendedor y Supervisor\n",
    "df_Otorgamientos = df_Otorgamientos.loc[:, ['Id Credito', 'Nombre Vendedor', 'Nombre Supervisor','Producto']]\n",
    "columna_duplicados = 'Id Credito'\n",
    "\n",
    "# Eliminar las filas duplicadas basadas en la columna especificada\n",
    "df_Otorgamientos = df_Otorgamientos.drop_duplicates(subset=[columna_duplicados])\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "fd7e9043",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Proceso de la base de demograficos.\n",
    "df_Demograficos = df_Demograficos.loc[:, ['iPersonId','vMobile','vStreetAd','vExtNumberAd','vIntNumberAd','vCornerAd','vCCornerAd','vNeighborhoodAd','vTownshipAd','vStateIdAd','iZipAd','vPhoneNumberAd']]\n",
    "df_Demograficos.fillna('X', inplace=True)\n",
    "df_Demograficos = df_Demograficos.astype(str)\n",
    "df_Demograficos['Domicilio'] = df_Demograficos['vStreetAd'].str.cat([df_Demograficos['vExtNumberAd'], df_Demograficos['vIntNumberAd']], sep=' ')\n",
    "df_Demograficos['Entre Calles'] = df_Demograficos['vCornerAd'].str.cat(df_Demograficos['vCCornerAd'], sep=' y ')\n",
    "df_Demograficos = df_Demograficos.loc[:, ['iPersonId','vMobile','vPhoneNumberAd','Domicilio','Entre Calles','vNeighborhoodAd','vTownshipAd','vStateIdAd','iZipAd']]\n",
    "df_Demograficos = df_Demograficos.rename(columns={'vMobile': 'Teléfono 1', 'vPhoneNumberAd': 'Teléfono 2','vNeighborhoodAd':'Colonia','vTownshipAd':'Ciudad Demograficos','vStateIdAd':'Estado Demograficos','iZipAd':'Codigo Postal'})\n",
    "df_Demograficos['iPersonId'] = df_Demograficos['iPersonId'].astype(int)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "9fbbfc70",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Cambiamos el Estatus para los creditos Por Disperarsar a Activos.\n",
    "df_Cartera['Estatus'] = df_Cartera['Estatus'].replace('Por Dispersar', 'Activo')\n",
    "df_Cartera['Estatus'] = df_Cartera['Estatus'].replace('Pend Cobro Banco', 'Activo')\n",
    "\n",
    "# Filtrar los valores de la columna 'Estado' que sean igual a 'Castigado' y crear una lista\n",
    "lista_castigados = df_Cartera[df_Cartera['Estatus'] == 'Castigado']['Id Credito'].tolist()\n",
    "\n",
    "\n",
    "#Aplicamos la funcion a la base de datos para agregar el bkt \n",
    "#df_Cartera['Bkt Inicial'] = df_Cartera.apply(lambda row: determinar_bktinicial(row['Estatus'], row['DiasAtraso']), axis=1)\n",
    "df_Cartera['Bkt Inicial'] = df_Cartera.apply(lambda row: determinar_bktinicial(row['Estatus'], row['DiasAtraso'], row['Tipo Financiamiento']), axis=1)\n",
    "\n",
    "df_Cartera['Bkt Inicial'] = df_Cartera['Bkt Inicial'].astype(str)\n",
    "\n",
    "\n",
    "# obtener la fecha de hoy\n",
    "fecha_hoy_str = datetime.datetime.today().strftime('%d/%m/%Y')\n",
    "fecha_hoy = datetime.datetime.strptime(fecha_hoy_str, '%d/%m/%Y')\n",
    "\n",
    "# agregar la columna 'Fecha' con la fecha de hoy al DataFrame\n",
    "df_Cartera['Fecha Ingreso'] = fecha_hoy\n",
    "\n",
    "df_CarteraParcial = df_Cartera.loc[:, ['Id Credito','DiasAtraso','Bkt Inicial','Fecha Ingreso']]\n",
    "df_CarteraParcial.rename(columns={'DiasAtraso': 'DiasAtraso Inicial'}, inplace=True)\n",
    "\n",
    "df_CarteraAlmacenada = pd.read_excel(\"C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/SaldosCarteraIniciales.xlsx\")\n",
    "df_CarteraNoAlmacenada = pd.merge(df_CarteraParcial, df_CarteraAlmacenada['Id Credito'], on='Id Credito', how='left', indicator=True)\\\n",
    "              .query(\"_merge == 'left_only'\")\\\n",
    "              .drop('_merge', axis=1)\n",
    "\n",
    "#Preguntamos el numero de Creditos ya en asignación para saber si es carga inicial o parcial de asignacion.\n",
    "num_filas = df_CarteraAlmacenada.shape[0]\n",
    "if num_filas == 0:\n",
    "    df_CarteraFinal = df_CarteraNoAlmacenada\n",
    "else:\n",
    "    df_CarteraFinal = pd.concat([df_CarteraAlmacenada,df_CarteraNoAlmacenada])\n",
    "    \n",
    "#Aplicamos Rename para cambiar el nombre de bkt inicial a actual\n",
    "df_Cartera.rename(columns={'Bkt Inicial': 'Bkt Actual'}, inplace=True)\n",
    "df_Cartera.drop(['Fecha Ingreso'], axis=1, inplace=True)\n",
    "\n",
    "df_Cartera = pd.merge(df_Cartera, df_CarteraFinal, left_on='Id Credito', right_on='Id Credito', how='left')\n",
    "\n",
    "# Convierte la columna de fechas a tipo datetime\n",
    "df_Cartera['Fecha Ingreso'] = pd.to_datetime(df_Cartera['Fecha Ingreso'], format='%d/%m/%Y')\n",
    "\n",
    "df_Cartera = df_Cartera.drop(['Afiliado','Comisión','Intereses Totales','Capital Pagado','Interes Pagado','IVA Int. Pagado','Cargo P.Tardio Pagado','Moratorio Pagado','Pago en Exceso','Comisión pagada','Ajustes Capital','Saldo Interes','Saldo IVA Int.','Saldo Cargo P.Tardio','Saldo Moratorios','Saldo Pago Exceso','Saldo comisión','Id Convenio','Ultimo Pago','Capital Vigente','Capital Vencido','Intereses Vencidos','Sdo Total c/ListasCobro','Sdo Vencido c/ListCobro','Estatus Cartera','CuotasAtraso','Gestor','ComVigente','ComVencida','ValidaDomi','vAfiliateIdO','vAfiliateO','Saldo Retención Adm','RFC','nRetencion','nJoPay','iMaxDays','vMaxDate','nLiquidate','nLiqPrin','nLiqInt','nLiqMor','nLiqCha','nLiqPrinTran','nLiqIntTran','nLiqMorTran','nLiqChaTran','nLiqRetTran','nCAT','vOpTable'], axis=1)\n",
    "\n",
    "df_Cartera['% Avance'] = df_Cartera['Amort. Pagadas']/df_Cartera['Pagos']\n",
    "\n",
    "# Definir las condiciones y etiquetas para cada rango\n",
    "condiciones = [\n",
    "    (df_Cartera['% Avance'] == 0) & (df_Cartera['1erPagoTeorico'] >= fecha_actual),\n",
    "    (df_Cartera['% Avance'] == 0) & (df_Cartera['1erPagoTeorico'] < fecha_actual),\n",
    "    df_Cartera['% Avance'] < 0.26,\n",
    "    df_Cartera['% Avance'] < 0.51,\n",
    "    df_Cartera['% Avance'] < 0.76,\n",
    "    df_Cartera['% Avance'] >= 0.76\n",
    "]\n",
    "etiquetas = ['No Devengado', 'FPD', '1-25%', '26-50%', '51-75%', '76-100%']\n",
    "\n",
    "# Utilizar np.select para asignar una etiqueta a cada valor en función de la condición que cumpla\n",
    "df_Cartera['Rango Avance'] = np.select(condiciones, etiquetas)\n",
    "\n",
    "\n",
    "df_Cartera = df_Cartera.rename(columns={'Amort. Pagadas': 'AmortPagadas'})\n",
    "df_Cartera['Cuotas Pag Rango'] = df_Cartera.apply(lambda row: determinar_CuotasPagadas(row['Estatus'], row['AmortPagadas']), axis=1)\n",
    "\n",
    "df_total_creditos = df_Cartera.groupby('IdPersona')['Id Credito'].count().reset_index()\n",
    "df_total_creditos.columns = ['IdPersona', 'TotalCreditos']\n",
    "\n",
    "# Calcula la cantidad de créditos por cliente para cada estatus\n",
    "df_creditos_por_estatus = df_Cartera.groupby(['IdPersona', 'Estatus'])['Id Credito'].count().unstack().reset_index()\n",
    "\n",
    "# Renombra las columnas para que reflejen el estatus\n",
    "df_creditos_por_estatus.columns = ['IdPersona'] + [f'Creditos_{Estatus}' for Estatus in df_creditos_por_estatus.columns[1:]]\n",
    "\n",
    "# Agrupar por la columna \"persona\" y calcular la suma del saldo vencido para cada grupo\n",
    "df_Cartera['Vencido Cliente'] = df_Cartera.groupby('IdPersona')['Vencido'].transform('sum')\n",
    "\n",
    "# Encontrar la fecha más antigua por cliente\n",
    "df_Cartera['Antiguedad Cliente'] = df_Cartera.groupby('IdPersona')['F.Desembolso'].transform('min')\n",
    "\n",
    "# Obtiene el último día del mes actual\n",
    "ultimo_dia_mes_actual = pd.Timestamp(fecha_actual.year, fecha_actual.month, 1) + pd.offsets.MonthEnd(0)\n",
    "\n",
    "# Convierte la columna de fechas a tipo datetime\n",
    "df_Cartera['Fecha Ingreso'] = pd.to_datetime(df_Cartera['Fecha Ingreso'], format='%d/%m/%Y')\n",
    "\n",
    "# Calcula la cantidad de días entre cada fecha y el último día del mes actual\n",
    "df_Cartera['Dias para terminar el mes'] = (ultimo_dia_mes_actual - df_Cartera['Fecha Ingreso']).dt.days\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "77ac7699",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Convertir las listas en conjuntos y unificarlos\n",
    "conjunto_unificado = set(lista_castigados).union(listaQuebrantosR1)\n",
    "\n",
    "# Convertir el conjunto resultante de nuevo en una lista (si es necesario)\n",
    "ListaQuebrantoTotal = list(conjunto_unificado)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "ce59e56b",
   "metadata": {},
   "outputs": [],
   "source": [
    "df_CarteraFinal.to_excel('C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/SaldosCarteraIniciales.xlsx', index=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "e93ab426",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Cantidad de valores NaN eliminados en la columna \"Pago\": 0\n"
     ]
    }
   ],
   "source": [
    "# Procesamos el archivo de pagos\n",
    "dfHistoricoPagos = dfHistoricoPagos.dropna(subset=['Origen de Movimiento']).loc[~dfHistoricoPagos['Origen de Movimiento'].isin(['Pago Refinanciamiento', 'Pago en Exceso', 'Pago Reestructura', 'Otros Ingresos Cartera'])]\n",
    "dfHistoricoPagos['IdPersona'] = dfHistoricoPagos['Id Credito'].map(dic_Cartera)\n",
    "dfHistoricoPagos = dfHistoricoPagos[~dfHistoricoPagos['Id Pago'].isin(lista)].copy()\n",
    "\n",
    "# Convertir la columna 'Fecha Aplicación' al tipo datetime\n",
    "dfHistoricoPagos['Fecha Aplicación'] = pd.to_datetime(dfHistoricoPagos['Fecha Aplicación'], format='%d/%m/%Y')\n",
    "\n",
    "# Contar NaNs en la columna 'Pago' antes de la conversión\n",
    "nan_count_before = dfHistoricoPagos['Pago'].isna().sum()\n",
    "\n",
    "# Convertir la columna 'Pago' a tipo float, manejando errores\n",
    "dfHistoricoPagos['Pago'] = pd.to_numeric(dfHistoricoPagos['Pago'], errors='coerce')\n",
    "\n",
    "# Contar NaNs en la columna 'Pago' después de la conversión\n",
    "nan_count_after = dfHistoricoPagos['Pago'].isna().sum()\n",
    "\n",
    "# Contar los NaNs que se eliminarán\n",
    "nan_count_eliminated = nan_count_after - nan_count_before\n",
    "\n",
    "# Asegúrate de que no haya valores NaN después de la conversión\n",
    "dfHistoricoPagos.dropna(subset=['Pago'], inplace=True)\n",
    "\n",
    "# Obtener el mes y año actuales y anteriores\n",
    "mes_actual = fecha_actual.month\n",
    "año_actual = fecha_actual.year\n",
    "mes_anterior = fecha_actual.month - 1 if fecha_actual.month > 1 else 12\n",
    "año_anterior = fecha_actual.year - 1 if mes_anterior == 12 else fecha_actual.year\n",
    "\n",
    "fecha_inicio = fecha_actual - pd.DateOffset(days=30)\n",
    "fecha_inicio_15_dias = fecha_actual - pd.DateOffset(days=15)\n",
    "\n",
    "# Filtrar el DataFrame por el mes y año actual\n",
    "dfPagosMesActual = dfHistoricoPagos[(dfHistoricoPagos['Fecha Aplicación'].dt.month == mes_actual) & (dfHistoricoPagos['Fecha Aplicación'].dt.year == año_actual)].copy()\n",
    "\n",
    "dfPagadoMesActual = dfPagosMesActual.groupby('Id Credito', as_index=False)['Pago'].sum()\n",
    "dfPagadoMesActual.rename(columns={'Pago': 'Pago Mes Vigente'}, inplace=True)\n",
    "\n",
    "# Agrupar y sumar los pagos por 'IdPersona'\n",
    "dfPagadoPersona = dfHistoricoPagos.groupby('IdPersona', as_index=False)['Pago'].sum()\n",
    "dfPagadoPersona.rename(columns={'Pago': 'Pago Total Cliente'}, inplace=True)\n",
    "\n",
    "# Agrupar y sumar los pagos por 'Id Credito'\n",
    "dfPagadoCredito = dfHistoricoPagos.groupby('Id Credito', as_index=False)['Pago'].sum()\n",
    "dfPagadoCredito.rename(columns={'Pago': 'Pago Total Crédito'}, inplace=True)\n",
    "\n",
    "# Los pagos recibidos del mes anterior\n",
    "dfPagosMesAnterior = dfHistoricoPagos[(dfHistoricoPagos['Fecha Aplicación'].dt.month == mes_anterior) & (dfHistoricoPagos['Fecha Aplicación'].dt.year == año_anterior)].copy()\n",
    "\n",
    "# Utilizar pivot_table para agrupar los pagos por Id Credito\n",
    "dfPagosTablaMesAnterior = pd.pivot_table(dfPagosMesAnterior, values='Pago', index='Id Credito', aggfunc='sum').reset_index()\n",
    "dfPagosTablaMesAnterior.rename(columns={'Pago': 'Pago Mes Anterior'}, inplace=True)\n",
    "\n",
    "# Filtrar pagos de los últimos 30 días\n",
    "dfUltimos30Dias = dfHistoricoPagos[(dfHistoricoPagos['Fecha Aplicación'] >= fecha_inicio) & (dfHistoricoPagos['Fecha Aplicación'] <= fecha_actual)].copy()\n",
    "dfUltimos30Dias = pd.pivot_table(dfUltimos30Dias, values='Pago', index='Id Credito', aggfunc='sum').reset_index()\n",
    "dfUltimos30Dias.rename(columns={'Pago': 'Pago 30 Dias'}, inplace=True)\n",
    "\n",
    "# Filtrar pagos de los últimos 15 días\n",
    "dfUltimos15Dias = dfHistoricoPagos[(dfHistoricoPagos['Fecha Aplicación'] >= fecha_inicio_15_dias) & (dfHistoricoPagos['Fecha Aplicación'] <= fecha_actual)].copy()\n",
    "dfUltimos15Dias = pd.pivot_table(dfUltimos15Dias, values='Pago', index='Id Credito', aggfunc='sum').reset_index()\n",
    "dfUltimos15Dias.rename(columns={'Pago': 'Pago 15 Dias'}, inplace=True)\n",
    "\n",
    "print(f'Cantidad de valores NaN eliminados en la columna \"Pago\": {nan_count_eliminated}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "b315c1a2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Procesar el archivo de pagos quebranto\n",
    "dfHistoricoPagosQuebranto = dfHistoricoPagos[dfHistoricoPagos['Id Credito'].isin(ListaQuebrantoTotal)].copy()\n",
    "dfHistoricoPagosQuebranto['FechaQuebranto'] = dfHistoricoPagosQuebranto['Id Credito'].map(dic_fechaQuebranto)\n",
    "\n",
    "# Calcular la diferencia en meses\n",
    "dfHistoricoPagosQuebranto['DiferenciaDias'] = dfHistoricoPagosQuebranto['Fecha Aplicación'] - dfHistoricoPagosQuebranto['FechaQuebranto']\n",
    "# Obtener el valor numérico de la diferencia en días\n",
    "dfHistoricoPagosQuebranto['DiferenciaDias'] = dfHistoricoPagosQuebranto['DiferenciaDias'].dt.days\n",
    "\n",
    "dfHistoricoPagosQuebranto['DiferenciaMeses'] = dfHistoricoPagosQuebranto['DiferenciaDias']/30\n",
    "\n",
    "# Filtrar las filas donde 'DiferenciaMeses' sea mayor que 0\n",
    "dfHistoricoPagosQuebranto = dfHistoricoPagosQuebranto[dfHistoricoPagosQuebranto['DiferenciaMeses'] > 0]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "fe4e96a2",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Definir una lista de condiciones\n",
    "condiciones = [3, 6, 9, 12, 15, 18, 21, 24]\n",
    "\n",
    "# Crear un DataFrame único con la columna 'Id Credito'\n",
    "df_resultado = dfHistoricoPagosQuebranto[['Id Credito']].drop_duplicates()\n",
    "\n",
    "# Iterar a través de las condiciones\n",
    "for condicion in condiciones:\n",
    "    # Filtrar las filas donde 'DiferenciaMeses' cumple la condición actual\n",
    "    df_filtrado = dfHistoricoPagosQuebranto[dfHistoricoPagosQuebranto['DiferenciaMeses'].apply(lambda x: x <= condicion)]\n",
    "    \n",
    "    # Sumar los valores de la columna 'Pago' agrupados por 'Id Credito' en el DataFrame original\n",
    "    suma_pagos = df_filtrado.groupby('Id Credito')['Pago'].sum().reset_index()\n",
    "    \n",
    "    # Renombrar la columna de pagos con la condición\n",
    "    suma_pagos = suma_pagos.rename(columns={'Pago': f'Pago_DiferenciaMeses_{condicion}'})\n",
    "    \n",
    "    # Combinar con el DataFrame único por 'Id Credito' en df_resultado\n",
    "    df_resultado = df_resultado.merge(suma_pagos, on='Id Credito', how='left')\n",
    "\n",
    "# Sumar todos los valores de la columna 'Pago' agrupados por 'Id Credito' en el DataFrame original\n",
    "suma_total_pagos = dfHistoricoPagosQuebranto.groupby('Id Credito')['Pago'].sum().reset_index()\n",
    "\n",
    "# Combinar la suma total de pagos por 'Id Credito' con df_resultado\n",
    "df_resultado = df_resultado.merge(suma_total_pagos, on='Id Credito', how='left')\n",
    "\n",
    "# Renombrar la columna de pagos totales\n",
    "df_resultado = df_resultado.rename(columns={'Pago': 'Pago_DiferenciaMeses_Completo'})\n",
    "\n",
    "# Ahora, df_resultado contendrá un DataFrame con 'Id Credito' como columna única y columnas de pagos para cada condición,\n",
    "# además de una columna 'Pago_DiferenciaMeses_Completo' que contiene la suma total de todos los pagos en el DataFrame original.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "04a1593b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Crear un DataFrame a partir de la lista\n",
    "dfQuebrantosPagosJorge = pd.DataFrame({'Id Credito': ListaQuebrantoTotal})\n",
    "\n",
    "# Hacer un join entre los dos DataFrames en base a la columna de crédito\n",
    "dfQuebrantosPagosJorge = pd.merge(dfQuebrantosPagosJorge, df_InfoQuebrantos, left_on='Id Credito', right_on='Operacion')\n",
    "dfQuebrantosPagosJorge = dfQuebrantosPagosJorge.drop(columns='Operacion')\n",
    "\n",
    "# Hacer un join entre los dos DataFrames en base a la columna de crédito\n",
    "dfQuebrantosPagosJorge = pd.merge(dfQuebrantosPagosJorge, df_resultado, on='Id Credito', how='left')\n",
    "\n",
    "\n",
    "# Llenar los valores NaN con 0 en el DataFrame\n",
    "dfQuebrantosPagosJorge = dfQuebrantosPagosJorge.fillna(0)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "553f795f",
   "metadata": {},
   "source": [
    "### Proceso para preparar la base de gestiones completa con el área del gestor, resultado obtenido y filtrar por las gestiones del mes actual.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "559654e0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Convertir la columna de fecha a tipo datetime\n",
    "appended_df['Fecha Actividad'] = pd.to_datetime(appended_df['Fecha Actividad'], format='%d/%m/%Y')\n",
    "\n",
    "# Obtener la fecha límite para filtrar (último día del mes anterior)\n",
    "fecha_limite = fecha_actual.replace(day=1) - pd.DateOffset(days=1)\n",
    "\n",
    "# Concatenar las columnas 2 en adelante\n",
    "df_concatenado = appended_df.iloc[:, 1:].apply(lambda x: '_'.join(x.dropna().astype(str)), axis=1)\n",
    "\n",
    "# Añadir la columna concatenada al DataFrame original\n",
    "appended_df['Concatenado'] = df_concatenado\n",
    "\n",
    "# Eliminar las filas duplicadas basándose en la columna concatenada\n",
    "appended_df = appended_df.drop_duplicates(subset='Concatenado')\n",
    "\n",
    "# Eliminar la columna concatenada si no es necesaria\n",
    "appended_df = appended_df.drop(columns='Concatenado')\n",
    "\n",
    "appended_df['Resultado Avance'] = appended_df['Resultado'].map(dic_ResultadoAvance)\n",
    "appended_df['Resultado Avance'] = appended_df['Resultado Avance'].fillna('SinR')\n",
    "\n",
    "appended_df['Usuario Registro'] = appended_df['Usuario Registro'].str.replace(' ', '')\n",
    "appended_df['Area Gestor'] = appended_df['Usuario Registro'].map(dic_AreaGestor)\n",
    "\n",
    "# Obtener el número de filas del DataFrame\n",
    "num_filas = appended_df.shape[0]\n",
    "\n",
    "# Crear una lista de valores consecutivos\n",
    "consecutivo = list(range(1, num_filas + 1))\n",
    "\n",
    "# Agregar la columna \"Consecutivo\" al DataFrame\n",
    "appended_df['INDICE'] = consecutivo\n",
    "\n",
    "# Filtrar las filas anteriores a la fecha límite\n",
    "df_GestionesHistoria = appended_df[appended_df['Fecha Actividad'] <= fecha_limite]\n",
    "\n",
    "# Filtrar las filas del mes actual\n",
    "df_Gestiones = appended_df[\n",
    "    (appended_df['Fecha Actividad'].dt.year == fecha_actual.year) & (appended_df['Fecha Actividad'].dt.month == fecha_actual.month)\n",
    "]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "08030bf6",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Agregamos a la cartera las Causas de no Pago y No domiciliación \n",
    "dfMotivoNoPagoNoDomi = appended_df.loc[appended_df['Area Gestor'].isin(['Despacho','D2D','Legal','CC','Nómina'])]\n",
    "dfMotivoNoPagoNoDomi = dfMotivoNoPagoNoDomi.loc[dfMotivoNoPagoNoDomi['Resultado Avance'].isin(['PTP','RPC'])]\n",
    "dfMotivoNoPagoNoDomi = dfMotivoNoPagoNoDomi.dropna(subset=['Causa de No Pago', 'Causa No Domiciliación'])\n",
    "\n",
    "\n",
    "# Ordenar el DataFrame por 'id_credito' y 'fecha_registro' en orden descendente\n",
    "dfMotivoNoPagoNoDomi = dfMotivoNoPagoNoDomi.sort_values(by=['Credito', 'Fecha Actividad'], ascending=[True, False])\n",
    "\n",
    "# Eliminar duplicados manteniendo la primera fila (la más reciente)\n",
    "dfMotivoNoPagoNoDomi = dfMotivoNoPagoNoDomi.drop_duplicates(subset='Credito', keep='first')\n",
    "\n",
    "dfMotivoNoPagoNoDomi = dfMotivoNoPagoNoDomi.loc[:, ['Credito','Causa de No Pago','Causa No Domiciliación']]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "df354d0d",
   "metadata": {},
   "outputs": [],
   "source": [
    "df_Quebrantos = df_Quebrantos.loc[:, ['SdoTotalX.Pagar','Estrategias','Operacion','Recuperación','Quebranto Contable','Capital Quebrantado','FechaQuebranto']]\n",
    "df_Quebrantos['Saldo Pagare'] = df_Quebrantos['SdoTotalX.Pagar']+df_Quebrantos['Estrategias']\n",
    "df_Quebrantos['Saldo Q_Contable'] = df_Quebrantos['Quebranto Contable']-df_Quebrantos['Recuperación']\n",
    "df_Quebrantos['Saldo Q_Capital'] = df_Quebrantos['Capital Quebrantado']-df_Quebrantos['Recuperación']\n",
    "\n",
    "df_Quebrantos = df_Quebrantos.loc[:, ['Operacion','Saldo Pagare','Saldo Q_Contable','Saldo Q_Capital','Recuperación','FechaQuebranto']]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "50097591",
   "metadata": {},
   "source": [
    "### Procesamos el archivo de gestiones y promesas."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "69953fc9",
   "metadata": {},
   "outputs": [],
   "source": [
    "df_GestionesHistoria = df_GestionesHistoria.loc[df_GestionesHistoria['Area Gestor'].isin(['Despacho','D2D','Legal','CC','Nómina'])]\n",
    "dfHistoriaResultados = df_GestionesHistoria\n",
    "\n",
    "df_GestionesHistoria['Contacto Generado'].fillna('', inplace=True)\n",
    "df_GestionesHistoria = df_GestionesHistoria[~((df_GestionesHistoria['Area Gestor'] == 'D2D') & (~df_GestionesHistoria['Contacto Generado'].str.contains('Visita')))]\n",
    "df_GestionesHistoria = df_GestionesHistoria[~df_GestionesHistoria['Contacto Generado'].str.contains('Mensaje')]\n",
    "\n",
    "TablaHistoriaGestiones = pd.pivot_table(df_GestionesHistoria, \n",
    "                              values='INDICE', \n",
    "                              index=['Credito'], \n",
    "                              columns=['Area Gestor'], \n",
    "                              aggfunc='count', \n",
    "                              fill_value=0)\n",
    "TablaHistoriaGestiones = TablaHistoriaGestiones.reset_index()\n",
    "#TablaHistoriaGestiones = TablaHistoriaGestiones.add_prefix('Historia ')\n",
    "TablaHistoriaGestiones['Historia Gestiones Externos'] = TablaHistoriaGestiones['Despacho'] + TablaHistoriaGestiones['Legal']+TablaHistoriaGestiones['Nómina']\n",
    "TablaHistoriaGestiones = TablaHistoriaGestiones.drop(['Despacho','Legal','Nómina'], axis=1)\n",
    "TablaHistoriaGestiones.rename(columns={'CC': 'Historia Llamadas','D2D':'Historia Visitas'}, inplace=True)\n",
    "TablaHistoriaGestiones['Historia Gestiones'] = TablaHistoriaGestiones['Historia Llamadas'] + TablaHistoriaGestiones['Historia Visitas']+TablaHistoriaGestiones['Historia Gestiones Externos']\n",
    "TablaHistoriaGestiones = TablaHistoriaGestiones.reindex(columns=['Credito', 'Historia Gestiones', 'Historia Llamadas','Historia Visitas','Historia Gestiones Externos'])\n",
    "\n",
    "dfHistoriaResultados = dfHistoriaResultados.loc[dfHistoriaResultados['Resultado Avance'].isin(['PTP','RPC'])]\n",
    "\n",
    "TablaHistoriaResultados = pd.pivot_table(dfHistoriaResultados, \n",
    "                              values='INDICE', \n",
    "                              index=['Credito'], \n",
    "                              columns=['Resultado Avance'], \n",
    "                              aggfunc='count', \n",
    "                              fill_value=0)\n",
    "TablaHistoriaResultados = TablaHistoriaResultados.add_prefix('Historia ')\n",
    "TablaHistoriaResultados = TablaHistoriaResultados.reset_index()\n",
    "TablaHistoriaResultados = TablaHistoriaResultados.reindex(columns=['Credito', 'Historia RPC', 'Historia PTP'])\n",
    "\n",
    "dfPromesasHistoria = dfHistoriaResultados\n",
    "dfPromesasHistoria = dfPromesasHistoria.loc[dfPromesasHistoria['Resultado Avance'].isin(['PTP'])]\n",
    "dfPromesasHistoria = dfPromesasHistoria.loc[dfPromesasHistoria['Monto Promesa'].notnull()]\n",
    "\n",
    "\n",
    "#dfPromesasHistoria.loc[dfPromesasHistoria['Resultado'] == '(027) Plan de Pago', 'Fecha Actividad'] = dfPromesasHistoria.loc[dfPromesasHistoria['Resultado'] == '(027) Plan de Pago', 'Fecha Promesa'] - datetime.timedelta(days=13)\n",
    "\n",
    "dfPromesasHistoria.drop(dfPromesasHistoria[dfPromesasHistoria['Resultado'] == 12].index, inplace=True)\n",
    "\n",
    "dfPromesasHistoria['Monto Promesa'] = dfPromesasHistoria['Monto Promesa'].str.replace('$', '', regex=False).str.replace(',', '', regex=False).astype(float)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "a2bfa90d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Suponiendo que el DataFrame de promesas de pago se llama dfPromesas y el DataFrame de pagos se llama dfPagos\n",
    "\n",
    "# Convertir las columnas de fecha en datetime si no están en ese formato\n",
    "dfPromesasHistoria['Fecha Actividad'] = pd.to_datetime(dfPromesasHistoria['Fecha Actividad'], format='%d/%m/%Y')\n",
    "dfPromesasHistoria['Fecha Promesa'] = pd.to_datetime(dfPromesasHistoria['Fecha Promesa'], format='%d/%m/%Y')\n",
    "dfHistoricoPagos['Fecha Pago'] = pd.to_datetime(dfHistoricoPagos['Fecha Pago'], format='%d/%m/%Y')\n",
    "\n",
    "dfPromesasHistoria['Fecha Actividad'] = dfPromesasHistoria['Fecha Actividad'].dt.date\n",
    "dfPromesasHistoria['Fecha Promesa'] = dfPromesasHistoria['Fecha Promesa'].dt.date\n",
    "dfHistoricoPagos['Fecha Pago'] = dfHistoricoPagos['Fecha Pago'].dt.date\n",
    "\n",
    "# Hacer un join entre los dos DataFrames en base a la columna de crédito\n",
    "dfPagosPromesas = pd.merge(dfPromesasHistoria, dfHistoricoPagos, left_on='Credito', right_on='Id Credito')\n",
    "# Filtrar los pagos que estén dentro del rango de fechas de la promesa\n",
    "dfPagosPromesas = dfPagosPromesas[(dfPagosPromesas['Fecha Pago'] >= dfPagosPromesas['Fecha Actividad']) & (dfPagosPromesas['Fecha Pago'] <= dfPagosPromesas['Fecha Promesa'])]\n",
    "\n",
    "# Ordenar el DataFrame por 'Fecha Actividad' de forma ascendente\n",
    "dfPagosPromesas = dfPagosPromesas.sort_values('Fecha Actividad')\n",
    "\n",
    "# Mantener solo el primer registro de cada 'Id Pago' duplicado manteniendo el más antiguo según 'Fecha Actividad'\n",
    "dfPagosPromesas = dfPagosPromesas.drop_duplicates(subset='Id Pago', keep='first')\n",
    "\n",
    "# Restablecer el índice del DataFrame resultante si es necesario\n",
    "dfPagosPromesas = dfPagosPromesas.reset_index(drop=True)\n",
    "\n",
    "# Sumar los pagos por crédito\n",
    "dfSumaPagosPorCredito = dfPagosPromesas.groupby('INDICE')['Pago'].sum().reset_index()\n",
    "\n",
    "dfPromesasHistoria = pd.merge(dfPromesasHistoria, dfSumaPagosPorCredito, left_on='INDICE', right_on='INDICE', how='left')\n",
    "\n",
    "dfPromesasHistoria['Pago'] = dfPromesasHistoria['Pago'].fillna(0)\n",
    "\n",
    "\n",
    "for index, row in dfPromesasHistoria.iterrows():\n",
    "    if row['Pago'] / row['Monto Promesa'] < 0.5:\n",
    "        if row['Fecha Promesa'] < hoy:\n",
    "            dfPromesasHistoria.at[index, 'Resultado PTP'] = 'Incumplida'\n",
    "        else:\n",
    "            dfPromesasHistoria.at[index, 'Resultado PTP'] = 'Vigente'\n",
    "    elif row['Pago'] / row['Monto Promesa'] < 1:\n",
    "        if row['Fecha Promesa'] < hoy:\n",
    "            dfPromesasHistoria.at[index, 'Resultado PTP'] = 'Parcial Vencida'\n",
    "        else:\n",
    "            dfPromesasHistoria.at[index, 'Resultado PTP'] = 'Parcial Vigente'\n",
    "    else:\n",
    "        dfPromesasHistoria.at[index, 'Resultado PTP'] = 'Cumplida'\n",
    "\n",
    "        \n",
    "TablaResultadosPTP = pd.pivot_table(dfPromesasHistoria, \n",
    "                              values='INDICE', \n",
    "                              index=['Credito'], \n",
    "                              columns=['Resultado PTP'], \n",
    "                              aggfunc='count', \n",
    "                              fill_value=0)\n",
    "TablaResultadosPTP = TablaResultadosPTP.add_prefix('Historia PTP ')\n",
    "TablaResultadosPTP = TablaResultadosPTP.reset_index()\n",
    "TablaResultadosPTP = TablaResultadosPTP.reindex(columns=['Credito', 'Historia PTP Cumplida', 'Historia PTP Parcial'])\n",
    "\n",
    "dfHistoriaFinal = pd.merge(TablaHistoriaGestiones, TablaHistoriaResultados, left_on='Credito', right_on='Credito', how='left')\n",
    "dfHistoriaFinal = pd.merge(dfHistoriaFinal, TablaResultadosPTP, left_on='Credito', right_on='Credito', how='left')\n",
    "dfHistoriaFinal = dfHistoriaFinal.fillna(0)\n",
    "dfHistoriaFinal['Historia PTP Rota'] = dfHistoriaFinal['Historia PTP'] - dfHistoriaFinal['Historia PTP Cumplida']-dfHistoriaFinal['Historia PTP Parcial']\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "a8c380be",
   "metadata": {},
   "outputs": [],
   "source": [
    "df_Gestiones = df_Gestiones.loc[df_Gestiones['Area Gestor'].isin(['Despacho','D2D','Legal','CC','Nómina'])]\n",
    "df_Gestiones['Area Gestor'] = np.where(~df_Gestiones['Area Gestor'].isin(['D2D', 'CC']), 'Gestiones Externos', df_Gestiones['Area Gestor'])\n",
    "\n",
    "dfResultados = df_Gestiones\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "df_Gestiones['Contacto Generado'].fillna('', inplace=True)\n",
    "#df_Gestiones = df_Gestiones[~((df_Gestiones['Area Gestor'] == 'D2D') & (~df_Gestiones['Contacto Generado'].str.contains('Visita')))]\n",
    "df_Gestiones = df_Gestiones[~df_Gestiones['Contacto Generado'].str.contains('Mensaje')]\n",
    "\n",
    "TablaGestiones = pd.pivot_table(df_Gestiones, \n",
    "                              values='INDICE', \n",
    "                              index=['Credito'], \n",
    "                              columns=['Area Gestor'], \n",
    "                              aggfunc='count', \n",
    "                              fill_value=0)\n",
    "TablaGestiones = TablaGestiones.reset_index()\n",
    "TablaGestiones.rename(columns={'CC': 'Llamadas','D2D':'Visitas'}, inplace=True)\n",
    "TablaGestiones['Gestiones'] = TablaGestiones['Llamadas'] + TablaGestiones['Visitas']+TablaGestiones['Gestiones Externos']\n",
    "TablaGestiones = TablaGestiones.reindex(columns=['Credito', 'Gestiones', 'Llamadas','Visitas','Gestiones Externos'])\n",
    "\n",
    "dfResultados = dfResultados.loc[dfResultados['Resultado Avance'].isin(['PTP','RPC'])]\n",
    "\n",
    "TablaResultados = pd.pivot_table(dfResultados, \n",
    "                              values='INDICE', \n",
    "                              index=['Credito'], \n",
    "                              columns=['Resultado Avance'], \n",
    "                              aggfunc='count', \n",
    "                              fill_value=0)\n",
    "TablaResultados = TablaResultados.reset_index()\n",
    "TablaResultados = TablaResultados.reindex(columns=['Credito', 'RPC', 'PTP'])\n",
    "\n",
    "dfPromesas = dfResultados\n",
    "dfPromesas = dfPromesas.loc[dfPromesas['Resultado Avance'].isin(['PTP'])]\n",
    "dfPromesas = dfPromesas.loc[dfPromesas['Monto Promesa'].notnull()]\n",
    "\n",
    "\n",
    "dfPromesas.drop(dfPromesas[dfPromesas['Resultado'] == 12].index, inplace=True)\n",
    "\n",
    "dfPromesas['Monto Promesa'] = dfPromesas['Monto Promesa'].str.replace('$', '', regex=False).str.replace(',', '', regex=False).astype(float)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "d14e1ebe",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Suponiendo que el DataFrame de promesas de pago se llama dfPromesas y el DataFrame de pagos se llama dfPagos\n",
    "\n",
    "# Convertir las columnas de fecha en datetime si no están en ese formato\n",
    "dfPromesas['Fecha Actividad'] = pd.to_datetime(dfPromesas['Fecha Actividad'], format='%Y-%m-%d')\n",
    "dfPromesas['Fecha Promesa'] = pd.to_datetime(dfPromesas['Fecha Promesa'], format='%d/%m/%Y')\n",
    "dfHistoricoPagos['Fecha Pago'] = pd.to_datetime(dfHistoricoPagos['Fecha Pago'], format='%Y-%m-%d')\n",
    "\n",
    "dfPromesas['Fecha Actividad'] = dfPromesas['Fecha Actividad'].dt.date\n",
    "dfPromesas['Fecha Promesa'] = dfPromesas['Fecha Promesa'].dt.date\n",
    "dfHistoricoPagos['Fecha Pago'] = dfHistoricoPagos['Fecha Pago'].dt.date\n",
    "\n",
    "# Hacer un join entre los dos DataFrames en base a la columna de crédito\n",
    "dfPagosPromesas = pd.merge(dfPromesas, dfHistoricoPagos, left_on='Credito', right_on='Id Credito')\n",
    "\n",
    "# Filtrar los pagos que estén dentro del rango de fechas de la promesa\n",
    "dfPagosPromesas = dfPagosPromesas[(dfPagosPromesas['Fecha Pago'] >= dfPagosPromesas['Fecha Actividad']) & (dfPagosPromesas['Fecha Pago'] <= dfPagosPromesas['Fecha Promesa'])]\n",
    "\n",
    "# Ordenar el DataFrame por 'Fecha Actividad' de forma ascendente\n",
    "dfPagosPromesas = dfPagosPromesas.sort_values('Fecha Actividad')\n",
    "\n",
    "# Mantener solo el primer registro de cada 'Id Pago' duplicado manteniendo el más antiguo según 'Fecha Actividad'\n",
    "dfPagosPromesas = dfPagosPromesas.drop_duplicates(subset='Id Pago', keep='first')\n",
    "\n",
    "# Restablecer el índice del DataFrame resultante si es necesario\n",
    "dfPagosPromesas = dfPagosPromesas.reset_index(drop=True)\n",
    "\n",
    "# Sumar los pagos por crédito\n",
    "dfSumaPagosPorCredito = dfPagosPromesas.groupby('INDICE')['Pago'].sum().reset_index()\n",
    "\n",
    "dfPromesas = pd.merge(dfPromesas, dfSumaPagosPorCredito, left_on='INDICE', right_on='INDICE', how='left')\n",
    "\n",
    "dfPromesas['Pago'] = dfPromesas['Pago'].fillna(0)\n",
    "\n",
    "\n",
    "for index, row in dfPromesas.iterrows():\n",
    "    if row['Pago'] / row['Monto Promesa'] < 0.5:\n",
    "        if row['Fecha Promesa'] < hoy:\n",
    "            dfPromesas.at[index, 'Resultado PTP'] = 'Incumplida'\n",
    "        else:\n",
    "            dfPromesas.at[index, 'Resultado PTP'] = 'Vigente'\n",
    "    elif row['Pago'] / row['Monto Promesa'] < 1:\n",
    "        if row['Fecha Promesa'] < hoy:\n",
    "            dfPromesas.at[index, 'Resultado PTP'] = 'Parcial Vencida'\n",
    "        else:\n",
    "            dfPromesas.at[index, 'Resultado PTP'] = 'Parcial Vigente'\n",
    "    else:\n",
    "        dfPromesas.at[index, 'Resultado PTP'] = 'Cumplida'\n",
    "\n",
    "        \n",
    "TablaResultadosPTP = pd.pivot_table(dfPromesas, \n",
    "                              values='INDICE', \n",
    "                              index=['Credito'], \n",
    "                              columns=['Resultado PTP'], \n",
    "                              aggfunc='count', \n",
    "                              fill_value=0)\n",
    "TablaResultadosPTP = TablaResultadosPTP.add_prefix('PTP ')\n",
    "TablaResultadosPTP = TablaResultadosPTP.reset_index()\n",
    "TablaResultadosPTP = TablaResultadosPTP.reindex(columns=['Credito','PTP Cumplida','PTP Parcial Vigente','PTP Parcial Vencida','PTP Vigente'])\n",
    "\n",
    "dfFinal = pd.merge(TablaGestiones, TablaResultados, left_on='Credito', right_on='Credito', how='left')\n",
    "dfFinal = pd.merge(dfFinal, TablaResultadosPTP, left_on='Credito', right_on='Credito', how='left')\n",
    "dfFinal = dfFinal.fillna(0)\n",
    "dfFinal['PTP Rota'] = dfFinal['PTP'] - dfFinal['PTP Cumplida']-dfFinal['PTP Parcial Vigente']-dfFinal['PTP Parcial Vencida']-dfFinal['PTP Vigente']\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "c247dbf3",
   "metadata": {},
   "outputs": [],
   "source": [
    "dfPromesasHistoria.to_excel('C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/PromesasResumenHistoria.xlsx', index=False)\n",
    "dfPromesas.to_excel('C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/PromesasResumen.xlsx', index=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8831fb89",
   "metadata": {},
   "source": [
    "### Adicionamos todos los diccionarios con el método .map"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "afc178e4",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Aplicamos el metodo map() para adicionar la columna de Estatus Legal.\n",
    "df_Cartera['Etapa Legal'] = df_Cartera['Id Credito'].map(dic_EtapaLegal)\n",
    "\n",
    "#Aplicamos el metodo map() para adicionar la columna de Estatus Legal.\n",
    "df_Cartera[['Etapa Legal_MC', 'Bandera PP Juicio']] = df_Cartera['Id Credito'].map(dic_EtapaLegalMC).apply(pd.Series)\n",
    "\n",
    "#Aplicamos el metodo map() para adicionar la columna de la unificacion de dependencias.\n",
    "df_Cartera['UN_Dependencia'] = df_Cartera['Dependencia'].map(dic_udDependencia)\n",
    "\n",
    "#Aplicamos el metodo map() para adicionar la columna de la unificacion de tipo de financiamiento\n",
    "df_Cartera['UN_Financiamiento'] = df_Cartera['Tipo Financiamiento'].map(dic_Financiamiento)\n",
    "\n",
    "#Aplicamos el metodo map() para adicionar la columna de la plaza por crédito\n",
    "df_Cartera['Plaza'] = df_Cartera['Id Credito'].map(dic_Plazas)\n",
    "\n",
    "# Eliminar duplicados\n",
    "df_no_duplicates = df_Cartera.drop_duplicates(subset=['Estado', 'Ciudad'])\n",
    "\n",
    "# Convertir el DataFrame sin duplicados a un diccionario\n",
    "plazas_dict = df_no_duplicates.set_index(['Estado', 'Ciudad'])['Plaza'].to_dict()\n",
    "\n",
    "# Llenar los valores faltantes en 'Plaza' utilizando el diccionario\n",
    "df_Cartera['Plaza'] = df_Cartera.apply(lambda x: plazas_dict[(x['Estado'], x['Ciudad'])] if pd.isna(x['Plaza']) else x['Plaza'], axis=1)\n",
    "\n",
    "#df_Cartera['Plaza'] = df_Cartera['Plaza'].fillna('Sin Plaza por el momento')\n",
    "\n",
    "#Procesamos la Clabe Interbancaria capturada para calcular el banco\n",
    "df_Cartera['Clabe Corta'] = df_Cartera['Clabe'].str.slice(start=1, stop=4)\n",
    "\n",
    "#Aplicamos el metodo map() para adicionar la columna del Banco Calculado\n",
    "df_Cartera['Banco Calculado'] = df_Cartera['Clabe Corta'].map(dic_Bancos)\n",
    "\n",
    "#Aplicamos el metodo map() para adicionar la columna del Estatus Domi\n",
    "df_Cartera['Estatus Domi'] = df_Cartera['Id Credito'].map(dic_EstatusDomi)\n",
    "\n",
    "#Aplicamos el metodo map() para adicionar la columna del Saldo Contable \n",
    "df_Cartera['Saldo Contable'] = df_Cartera['Id Credito'].map(dic_Contable)\n",
    "\n",
    "#Aplicamos el metodo map() para adicionar la columna de Defunción\n",
    "df_Cartera['EstatusDef'] = df_Cartera['IdPersona'].map(dic_EstatusDef)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "69ad6aa4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Aplica la función calcular_propenso_a_castigo a cada fila del DataFrame utilizando np.where()\n",
    "df_Cartera['Propenso a Castigo'] = np.where(df_Cartera['UN_Financiamiento'].isin(['DxD', 'DxN','DxS']), df_Cartera.apply(calcular_propenso_a_castigo, axis=1), False)\n",
    "\n",
    "#Aplicamos la función determinar_MesQuebranto para calcular el mes de quebranto segun los dias de atraso de los creditos Activos.\n",
    "df_Cartera['Mes Quebranto'] = df_Cartera.apply(lambda row: determinar_MesQuebranto(row['Estatus'], row['DiasAtraso'], row['UN_Financiamiento']), axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "12578e20",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "df_Cartera['Motivo'].fillna('NUEVO', inplace=True)\n",
    "# Combina los DataFrames en uno solo\n",
    "df_Cartera = pd.merge(df_Cartera, df_CatalogoMotivos, on='Motivo', how='left')\n",
    "\n",
    "mask = df_Cartera['UN_Financiamiento'] == 'DxD'\n",
    "columns_to_change = ['Motivo', 'Bandera Pago-No Pago Nómina', 'Bandera Baja Dependencia', 'Abreviatura']\n",
    "df_Cartera.loc[mask, columns_to_change] = 0\n",
    "\n",
    "mask = (df_Cartera['Estatus'] == 'Cerrado') & (df_Cartera['Motivo'] == 'NUEVO')\n",
    "df_Cartera.loc[mask, columns_to_change] = 0\n",
    "\n",
    "\n",
    "df_Cartera = pd.merge(df_Cartera, df_total_creditos, on='IdPersona', how='left')\n",
    "df_Cartera = pd.merge(df_Cartera, df_creditos_por_estatus, on='IdPersona', how='left')\n",
    "#Aplicamos el metodo merge para combinar la informacion de los 2 dataframes\n",
    "df_Cartera = pd.merge(df_Cartera, suma_dinero, left_on='IdPersona', right_on='Persona', how='left')\n",
    "df_Cartera = pd.merge(df_Cartera, suma_dineroCredito, left_on='Id Credito', right_on='Id Credito', how='left')\n",
    "\n",
    "df_Cartera = pd.merge(df_Cartera, dfPagadoPersona, left_on='IdPersona', right_on='IdPersona', how='left')\n",
    "\n",
    "df_Cartera = pd.merge(df_Cartera, dfPagadoCredito, left_on='Id Credito', right_on='Id Credito', how='left')\n",
    "\n",
    "#Realizamos un merge y procesamiento de las cuotas de pago para el mes anterior\n",
    "df_Cartera = pd.merge(df_Cartera, dfPagosTablaMesAnterior, left_on='Id Credito', right_on='Id Credito', how='left')\n",
    "df_Cartera['Pago Mes Anterior'] = df_Cartera['Pago Mes Anterior'].fillna(0)\n",
    "df_Cartera['Cuotas Pagadas Mes Anterior'] =df_Cartera['Pago Mes Anterior']/df_Cartera['Pago']\n",
    "\n",
    "# Definir las condiciones y etiquetas para cada rango\n",
    "condiciones = [\n",
    "    df_Cartera['Cuotas Pagadas Mes Anterior'] < 0,\n",
    "    df_Cartera['Cuotas Pagadas Mes Anterior'] == 0,\n",
    "    df_Cartera['Cuotas Pagadas Mes Anterior'] < 0.51,\n",
    "    df_Cartera['Cuotas Pagadas Mes Anterior'] < 0.99,\n",
    "    df_Cartera['Cuotas Pagadas Mes Anterior'] >= 0.99\n",
    "]\n",
    "etiquetas = ['Anulación', 'Sin Pago', '<50%', '51%-99%', '100%+']\n",
    "\n",
    "# Utilizar np.select para asignar una etiqueta a cada valor en función de la condición que cumpla\n",
    "df_Cartera['Rango Pagado Mes Anterior'] = np.select(condiciones, etiquetas)\n",
    "\n",
    "\n",
    "#Realizamos un merge y procesamiento de las cuotas de pago para el mes vigente\n",
    "df_Cartera = pd.merge(df_Cartera, dfPagadoMesActual, left_on='Id Credito', right_on='Id Credito', how='left')\n",
    "df_Cartera['Pago Mes Vigente'] = df_Cartera['Pago Mes Vigente'].fillna(0)\n",
    "df_Cartera['Cuotas Pagadas Mes Vigente'] =df_Cartera['Pago Mes Vigente']/df_Cartera['Pago']\n",
    "\n",
    "# Definir las condiciones y etiquetas para cada rango\n",
    "condiciones = [\n",
    "    df_Cartera['Cuotas Pagadas Mes Vigente'] < 0,\n",
    "    df_Cartera['Cuotas Pagadas Mes Vigente'] == 0,\n",
    "    df_Cartera['Cuotas Pagadas Mes Vigente'] < 0.51,\n",
    "    df_Cartera['Cuotas Pagadas Mes Vigente'] < 0.99,\n",
    "    df_Cartera['Cuotas Pagadas Mes Vigente'] >= 0.99\n",
    "]\n",
    "etiquetas = ['Anulación', 'Sin Pago', '<50%', '51%-99%', '100%+']\n",
    "\n",
    "# Utilizar np.select para asignar una etiqueta a cada valor en función de la condición que cumpla\n",
    "df_Cartera['Rango Pagado Mes Vigente'] = np.select(condiciones, etiquetas)\n",
    "\n",
    "#Realizamos un merge y procesamiento de las cuotas de pago para ultimos 30 dias\n",
    "df_Cartera = pd.merge(df_Cartera, dfUltimos30Dias, left_on='Id Credito', right_on='Id Credito', how='left')\n",
    "df_Cartera['Pago 30 Dias'] = df_Cartera['Pago 30 Dias'].fillna(0)\n",
    "df_Cartera['Cuotas Pagadas 30 Dias'] =df_Cartera['Pago 30 Dias']/df_Cartera['Pago']\n",
    "\n",
    "# Definir las condiciones y etiquetas para cada rango\n",
    "condiciones = [\n",
    "    df_Cartera['Cuotas Pagadas 30 Dias'] < 0,\n",
    "    df_Cartera['Cuotas Pagadas 30 Dias'] == 0,\n",
    "    df_Cartera['Cuotas Pagadas 30 Dias'] < 0.51,\n",
    "    df_Cartera['Cuotas Pagadas 30 Dias'] < 0.99,\n",
    "    df_Cartera['Cuotas Pagadas 30 Dias'] >= 0.99\n",
    "]\n",
    "etiquetas = ['Anulación', 'Sin Pago', '<50%', '51%-99%', '100%+']\n",
    "\n",
    "# Utilizar np.select para asignar una etiqueta a cada valor en función de la condición que cumpla\n",
    "df_Cartera['Rango Pagado 30 Dias'] = np.select(condiciones, etiquetas)\n",
    "\n",
    "\n",
    "#Realizamos un merge y procesamiento de las cuotas de pago para ultimos 15 dias\n",
    "df_Cartera = pd.merge(df_Cartera, dfUltimos15Dias, left_on='Id Credito', right_on='Id Credito', how='left')\n",
    "df_Cartera['Pago 15 Dias'] = df_Cartera['Pago 15 Dias'].fillna(0)\n",
    "df_Cartera['Cuotas Pagadas 15 Dias'] =df_Cartera['Pago 15 Dias']/df_Cartera['Pago']\n",
    "\n",
    "# Definir las condiciones y etiquetas para cada rango\n",
    "condiciones = [\n",
    "    df_Cartera['Cuotas Pagadas 15 Dias'] < 0,\n",
    "    df_Cartera['Cuotas Pagadas 15 Dias'] == 0,\n",
    "    df_Cartera['Cuotas Pagadas 15 Dias'] < 0.51,\n",
    "    df_Cartera['Cuotas Pagadas 15 Dias'] < 0.99,\n",
    "    df_Cartera['Cuotas Pagadas 15 Dias'] >= 0.99\n",
    "]\n",
    "etiquetas = ['Anulación', 'Sin Pago', '<50%', '51%-99%', '100%+']\n",
    "\n",
    "# Utilizar np.select para asignar una etiqueta a cada valor en función de la condición que cumpla\n",
    "df_Cartera['Rango Pagado 15 Dias'] = np.select(condiciones, etiquetas)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "df_Cartera['Bandera'] = np.where(df_Cartera['Rango Avance'] == \"FPD\", \"FPD\",\n",
    "                                 np.where(df_Cartera['Rango Avance'] == \"No Devengado\", \"No Devengado\",\n",
    "                                          df_Cartera['Rango Pagado Mes Anterior']))\n",
    "\n",
    "\n",
    "df_Cartera['Score'] = df_Cartera.apply(lambda row: determinar_Score(row['Cuotas Pag Rango'], row['Bandera'],row['DiasAtraso']), axis=1)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "df_Cartera['PagadoVsDispersado']= df_Cartera['Pago Total Cliente']/df_Cartera['Capital Total Dispersado']\n",
    "\n",
    "df_Cartera = pd.merge(df_Cartera, dfMotivoNoPagoNoDomi, left_on='Id Credito', right_on='Credito', how='left')\n",
    "df_Cartera = df_Cartera.drop(columns='Credito')\n",
    "df_Cartera = pd.merge(df_Cartera, dfHistoriaFinal, left_on='Id Credito', right_on='Credito', how='left')\n",
    "df_Cartera = df_Cartera.drop(columns='Credito')\n",
    "df_Cartera = pd.merge(df_Cartera, dfFinal, left_on='Id Credito', right_on='Credito', how='left')\n",
    "df_Cartera = df_Cartera.drop(columns='Credito')\n",
    "# Leemos el archivo Quebrantos Sin Estrategias para obtener los datos relevantes del credito quebrantado y anexamos a la base\n",
    "df_Cartera = pd.merge(df_Cartera, df_Quebrantos, left_on='Id Credito', right_on='Operacion', how='left')\n",
    "df_Cartera = df_Cartera.drop(columns='Operacion')\n",
    "df_Cartera = pd.merge(df_Cartera, df_Otorgamientos, left_on='Id Credito', right_on='Id Credito', how='left')\n",
    "df_Cartera = pd.merge(df_Cartera, df_Demograficos, left_on='IdPersona', right_on='iPersonId', how='left')\n",
    "df_Cartera = df_Cartera.drop(columns='iPersonId')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "1682604f",
   "metadata": {},
   "outputs": [],
   "source": [
    "df_Cartera.fillna(0, inplace=True)\n",
    "df_Cartera = df_Cartera.drop(columns='Dias para terminar el mes')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "dd565ce0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Supongamos que tienes un DataFrame llamado df con las columnas originales en un orden arbitrario\n",
    "column_order = ['Id Solicitud','Id Credito','IdPersona','Antiguedad Cliente','Capital Total Dispersado','Capital Total Dispersado Crédito','Pago Total Cliente','Pago Total Crédito','PagadoVsDispersado','Pago Mes Vigente','Cuotas Pagadas Mes Vigente','Rango Pagado Mes Vigente','Pago Mes Anterior','Cuotas Pagadas Mes Anterior','Rango Pagado Mes Anterior','Pago 30 Dias','Cuotas Pagadas 30 Dias','Rango Pagado 30 Dias','Pago 15 Dias','Cuotas Pagadas 15 Dias','Rango Pagado 15 Dias','Bandera','Score','Nombre','Monto','Monto Total','Pagos','AmortPagadas','% Avance','Rango Avance','Cuotas Pag Rango','vFondeador','Dependencia','UN_Dependencia','Tipo Financiamiento','UN_Financiamiento','Sucursal','Nombre Vendedor','Nombre Supervisor','F.Desembolso','Frecuencia','Tasa Int. Anual','Producto','Estatus','EstatusDef','Propenso a Castigo','Mes Quebranto','TotalCreditos','Creditos_Activo','Creditos_Castigado','Creditos_Cerrado','Etapa Legal','Etapa Legal_MC','Motivo','Bandera Pago-No Pago Nómina','Bandera Baja Dependencia','Abreviatura','Estado','Ciudad','Plaza','Total Pagado','Saldo Contable','Saldo Capital','Saldo Total','Importe de Pago','Vencido','Vencido Cliente','SdoInsoluto','Pago','Saldo Pagare','Saldo Q_Contable','Saldo Q_Capital','Recuperación','FechaQuebranto','Fecha Ingreso','1erPagoTeorico','1erPagoReal','Ultimo pago c/ListaCobro','Ultimo pago aplicado','DiasUltimoPago','MontoUltimoPago','DiasAtraso','Bkt Actual','PeriodosAtraso','DiasAtraso Inicial','Bkt Inicial','Sig Pago','Monto Sig Pago','vCommentExt','iPeriodsExt','vScoreBuro','vCollectStatus','Banco','Clabe','Clabe Corta','Banco Calculado','Estatus Domi','Causa de No Pago','Causa No Domiciliación','Historia Gestiones','Historia Llamadas','Historia Visitas','Historia Gestiones Externos','Historia RPC','Historia PTP','Historia PTP Cumplida','Historia PTP Parcial','Historia PTP Rota','Gestiones','Llamadas','Visitas','Gestiones Externos','RPC','PTP','PTP Cumplida','PTP Parcial Vigente','PTP Parcial Vencida','PTP Vigente','PTP Rota','Teléfono 1','Teléfono 2','Domicilio','Entre Calles','Colonia','Ciudad Demograficos','Estado Demograficos','Codigo Postal','Bandera PP Juicio','Referencia']  # Define el orden deseado de las columnas\n",
    "\n",
    "df_Cartera = df_Cartera.reindex(columns=column_order)\n",
    "\n",
    "df_Cartera = df_Cartera.sort_values(by='Id Credito', ascending=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "447d40bb",
   "metadata": {},
   "outputs": [],
   "source": [
    "#writer = pd.ExcelWriter('C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/BD_ops.xlsx', engine='xlsxwriter')\n",
    "#df_Cartera.to_excel(writer, sheet_name='Cartera General', index=False)\n",
    "#dfQuebrantosPagosJorge.to_excel(writer, sheet_name='BaseRecQuebrantos', index=False)\n",
    "#writer.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "6f485374",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "\n",
    "# Suponiendo que ya tienes un DataFrame llamado 'df' con las columnas necesarias\n",
    "# Dividir en tres DataFrames dependiendo del valor de 'UN_Financiamiento'\n",
    "df_dxd = df_Cartera[df_Cartera['UN_Financiamiento'] == 'DxD'].copy()\n",
    "df_dxn = df_Cartera[df_Cartera['UN_Financiamiento'] == 'DxN'].copy()\n",
    "df_dxs = df_Cartera[df_Cartera['UN_Financiamiento'] == 'DxS'].copy()\n",
    "\n",
    "# Crear una función para determinar el Tipo de Crédito basado en las reglas\n",
    "def determinar_tipo_credito(row):\n",
    "    if row['Tipo Financiamiento'] in ['ELEC', 'ELECPD', 'ELECREF', 'ELECRS']:\n",
    "        if row['Sucursal'] == 'CORPORATIVO MF' and row['Tipo Financiamiento'] == 'ELECRS':\n",
    "            return 'Reestructura'\n",
    "        elif row['Tipo Financiamiento'] == 'ELECRS':\n",
    "            return 'Refinanciamiento'\n",
    "        elif row['Tipo Financiamiento'] == 'ELECPD':\n",
    "            return 'Compra de Deuda'\n",
    "        elif row['Tipo Financiamiento'] == 'ELECREF':\n",
    "            return 'Refinanciamiento'\n",
    "        elif row['Tipo Financiamiento'] == 'ELEC':\n",
    "            return '1er Credito Electronico'\n",
    "    elif row['Tipo Financiamiento'] in ['NOM', 'NCCAR', 'REFI', 'REST']:\n",
    "        if row['Tipo Financiamiento'] == 'NCCAR':\n",
    "            return 'Compra de Deuda'\n",
    "        elif row['Tipo Financiamiento'] == 'REST':\n",
    "            return 'Refinanciamiento'\n",
    "        elif row['Tipo Financiamiento'] == 'REFI':\n",
    "            return 'Refinanciamiento'\n",
    "        elif row['Tipo Financiamiento'] == 'NOM':\n",
    "            return '1er Credito Nómina'\n",
    "    elif row['Tipo Financiamiento'] in ['NOM FACT', 'NOM ACT RF']:\n",
    "        if row['Tipo Financiamiento'] == 'NOM ACT RF':\n",
    "            return 'Refinanciamiento'\n",
    "        elif row['Tipo Financiamiento'] == 'NOM FACT':\n",
    "            return '1er Credito Sindicato'\n",
    "    else:\n",
    "        return 'Tipo de Crédito No Definido'\n",
    "\n",
    "# Aplicar la función a cada DataFrame\n",
    "df_dxd['Tipo de Credito'] = df_dxd.apply(determinar_tipo_credito, axis=1)\n",
    "df_dxn['Tipo de Credito'] = df_dxn.apply(determinar_tipo_credito, axis=1)\n",
    "df_dxs['Tipo de Credito'] = df_dxs.apply(determinar_tipo_credito, axis=1)\n",
    "\n",
    "# Separar 1er crédito o subsecuente por IdPersona\n",
    "def asignar_credito_subsecuente(df):\n",
    "    df = df.sort_values(by=['IdPersona', 'Id Credito'])\n",
    "    df['Tipo de Credito'] = df.groupby('IdPersona')['Tipo de Credito'].transform(\n",
    "        lambda x: x.where(x.index == x.index.min(), x.str.replace('1er Credito', 'Subsecuente'))\n",
    "    )\n",
    "    return df\n",
    "\n",
    "df_dxd = asignar_credito_subsecuente(df_dxd)\n",
    "df_dxn = asignar_credito_subsecuente(df_dxn)\n",
    "df_dxs = asignar_credito_subsecuente(df_dxs)\n",
    "\n",
    "# Unir los DataFrames nuevamente\n",
    "df_final = pd.concat([df_dxd, df_dxn, df_dxs])\n",
    "\n",
    "df_final = df_final.sort_values(by='Id Credito', ascending=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "id": "b45871a4",
   "metadata": {},
   "outputs": [],
   "source": [
    "writer = pd.ExcelWriter('C:/Users/Go Credit/Desktop/REPORTES/ProcesosPython/ProcesoReporteParaBitacora/BD_ops.xlsx', engine='xlsxwriter')\n",
    "#df_Cartera.to_excel(writer, sheet_name='Cartera General', index=False)\n",
    "df_final.to_excel(writer, sheet_name='Cartera General', index=False)\n",
    "dfQuebrantosPagosJorge.to_excel(writer, sheet_name='BaseRecQuebrantos', index=False)\n",
    "writer.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f73d2a3b",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
